/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtGIZMOFileFormat.C                           //
// ************************************************************************* //

#include <avtGIZMOFileFormat.h>

#include <cassert>
#include <cstring>
#include <string>
#include <vector>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkVertex.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidDBTypeException.h>
#include <InvalidVariableException.h>

#include <DebugStream.h>

#include <hdf5.h>

// Uncomment to debug the code
//#define GIZMO_PLUGIN_DEBUG

#ifdef GIZMO_PLUGIN_DEBUG

#ifdef debug4
#undef debug4
#endif

#define debug4 std::cout
#define MYH5CHECK(X) if((X) < 0) assert(false)

#else 

#define MYH5CHECK(X) if((X) < 0) \
        EXCEPTION1(InvalidDBTypeException, "The file could not be opened")

#endif

#define GIZMO_STRLEN 1024


using namespace std;

namespace {

herr_t gizmo_read_metadata(hid_t group_id, char const * name, void * metadata) {
  list<avtGIZMOFileFormat::Field> * md =
    reinterpret_cast<list<avtGIZMOFileFormat::Field> *>(metadata);

  debug4 << "\t\t/" << string(name) << endl;

  H5G_stat_t object_info;
  H5Gget_objinfo(group_id, name, 0, &object_info);
  if(object_info.type == H5G_DATASET && strcmp(name, "Coordinates") != 0) {
      avtGIZMOFileFormat::Field field;
    field.name = string(name);

    hid_t dset_id = H5Dopen(group_id, name, H5P_DEFAULT); MYH5CHECK(dset_id);
    hid_t dspc_id = H5Dget_space(dset_id); MYH5CHECK(dspc_id);
    field.rank = H5Sget_simple_extent_ndims(dspc_id); MYH5CHECK(field.rank);
    H5Sclose(dspc_id);
    H5Dclose(dset_id);

    md->push_back(field);
  }
  return 0;
}

}

// ****************************************************************************
//  Method: avtGIZMOFileFormat constructor
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

avtGIZMOFileFormat::avtGIZMOFileFormat(const char *filename)
    : avtSTSDFileFormat(filename), initialized(false), filename(filename)
{
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::Initialize
//
//  Purpose:
//      Read all of the necessary metadata from the file
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

void
avtGIZMOFileFormat::Initialize() {
  if(!initialized) {
    debug4 << "Initializing the plugin ..." << endl;
    ReadHeader();
    ReadMetadata();
    debug4 << "Done with initialization." << endl;
    initialized = true;
  }
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::ReadHeader
//
//  Purpose:
//      Read the header information
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

void
avtGIZMOFileFormat::ReadHeader() {
  if(!initialized) {
    debug4 << "Reading the header ..." << endl;
    hid_t file_id = H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
      MYH5CHECK(file_id);
    hid_t group_id = H5Gopen(file_id, "/Header", H5P_DEFAULT);
      MYH5CHECK(group_id);
    hid_t attr_id;
    herr_t ierr;

    attr_id = H5Aopen(group_id, "BoxSize", H5P_DEFAULT); MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_DOUBLE, &header.box_size);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Flag_Cooling", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.flag_cooling);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Flag_DoublePrecision", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.flag_double_precision);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Flag_Feedback", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.flag_feedback);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Flag_IC_Info", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.flag_ic_info);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Flag_Metals", H5P_DEFAULT); MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.flag_metals);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Flag_Sfr", H5P_DEFAULT); MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.flag_sfr);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Flag_StellarAge", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.flag_stellar_age);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "HubbleParam", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_DOUBLE, &header.hubble_param);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "MassTable", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_DOUBLE, &header.mass_table[0]);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "NumFilesPerSnapshot", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.num_files_per_snapshot);
      MYH5CHECK(ierr);

    attr_id = H5Aopen(group_id, "NumPart_ThisFile", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_INT, &header.num_part_this_file[0]);
      MYH5CHECK(ierr);

    attr_id = H5Aopen(group_id, "NumPart_Total", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_UINT, &header.num_part_total[0]);
      MYH5CHECK(ierr);

    attr_id = H5Aopen(group_id, "NumPart_Total_HighWord", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_UINT,
        &header.num_part_total_high_word[0]); MYH5CHECK(ierr);

    attr_id = H5Aopen(group_id, "Omega0", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_DOUBLE, &header.Omega0);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "OmegaLambda", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_DOUBLE, &header.OmegaLambda);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Redshift", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_DOUBLE, &header.redshift);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    attr_id = H5Aopen(group_id, "Time", H5P_DEFAULT);
      MYH5CHECK(attr_id);
    ierr = H5Aread(attr_id, H5T_NATIVE_DOUBLE, &header.time);
      MYH5CHECK(ierr);
    H5Aclose(attr_id);

    H5Gclose(group_id);
    H5Fclose(file_id);
    debug4 << "Done with the header." << endl;
  }
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::GetMetadata
//
//  Purpose:
//      Read the header information
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

void
avtGIZMOFileFormat::ReadMetadata() {
  if(!initialized) {
    debug4 << "Reading the metadata ..." << endl;
    hid_t file_id = H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
    MYH5CHECK(file_id);

    for(int ptype = 0; ptype < GIZMO_N_PTYPE; ++ptype) {
      if(header.num_part_this_file[ptype] > 0) {
        char gname[GIZMO_STRLEN];
        snprintf(gname, GIZMO_STRLEN, "PartType%d", ptype);
        debug4 << "\t/" << string(gname) << endl; 
        void * metadata = reinterpret_cast<void *>(&fields[ptype]);
        herr_t ierr = H5Giterate(file_id, gname, NULL, gizmo_read_metadata,
           metadata); MYH5CHECK(file_id);
      }
    }

    H5Fclose(file_id);
    debug4 << "Done with the metadata." << endl;
    initialized = true;
  }
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

void
avtGIZMOFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::GetTime
//
//  Purpose:
//      Get the current time
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

double
avtGIZMOFileFormat::GetTime() {
  Initialize();
  return header.time;
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

void
avtGIZMOFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
  this->Initialize();

  debug4 << "Exporting metadata to VisIt ..." << endl;

  for(int ptype = 0; ptype < GIZMO_N_PTYPE; ++ptype) {
    if(header.num_part_this_file[ptype] > 0) {
      // SPH particle grid
      avtMeshMetaData * mmd = new avtMeshMetaData;
      char mesh_name[GIZMO_STRLEN];
      snprintf(mesh_name, GIZMO_STRLEN, "PartType%d", ptype);
      debug4 << "\t/" << string(mesh_name) << endl;
      mmd->name = string(mesh_name);
      mmd->spatialDimension = 3;
      mmd->topologicalDimension = 0;
      mmd->meshType = AVT_POINT_MESH;
      mmd->numBlocks = 1;
      md->Add(mmd);

      std::list<avtGIZMOFileFormat::Field>::const_iterator it;
      for(it = fields[ptype].begin(); it != fields[ptype].end(); ++it) {
        // Scalar fields
        if(it->rank == 1) {
          avtScalarMetaData * smmd = new avtScalarMetaData;
          char field_name[GIZMO_STRLEN];
          snprintf(field_name, GIZMO_STRLEN, "PartType%d/%s",
              ptype, it->name.c_str());
          debug4 << "\t\t/" << it->name << endl;
          smmd->name = string(field_name);
          smmd->meshName = string(mesh_name);
          smmd->centering = AVT_NODECENT;
          smmd->hasUnits = false;
          md->Add(smmd);
        }
        // Vector fields
        else if(it->rank == 2) {
          avtVectorMetaData * vmmd = new avtVectorMetaData;
          char vector_name[GIZMO_STRLEN];
          snprintf(vector_name, GIZMO_STRLEN, "PartType%d/%s",
              ptype, it->name.c_str());
          debug4 << "\t\t/" << it->name << endl;
          vmmd->name = string(vector_name);
          vmmd->meshName = string(mesh_name);
          vmmd->centering = AVT_NODECENT;
          vmmd->hasUnits = false;
          vmmd->varDim = 3;
          md->Add(vmmd);
        }
        else {
          char errmsg[GIZMO_STRLEN];
          snprintf(errmsg, GIZMO_STRLEN, "Field \"%s\" has an unsupported "
              "rank = %d", it->name.c_str(), it->rank);
          EXCEPTION1(InvalidVariableException, errmsg);
        }
      }
    }
  }
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

vtkDataSet *
avtGIZMOFileFormat::GetMesh(const char *meshname)
{
  this->Initialize();

  debug4 << "Reading the \"" << string(meshname) << "\" mesh ..." << endl;

  int ptype;
  sscanf(meshname, "PartType%d", &ptype);
  if(ptype < 0 || ptype >= GIZMO_N_PTYPE) {
    char errmsg[GIZMO_STRLEN];
    snprintf(errmsg, GIZMO_STRLEN, "Unkown particle type: \"PartType%d\"",
        ptype);
    EXCEPTION1(InvalidDBTypeException, errmsg);
  }

  hid_t file_id = H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
    MYH5CHECK(file_id);
  hid_t group_id = H5Gopen(file_id, meshname, H5P_DEFAULT);
    MYH5CHECK(group_id);
  hid_t dset_id = H5Dopen(group_id, "Coordinates", H5P_DEFAULT);
    MYH5CHECK(dset_id);

  vtkPoints * points = vtkPoints::New();
  points->SetNumberOfPoints(header.num_part_this_file[ptype]);
  float * pts = static_cast<float *>(points->GetVoidPointer(0));

  herr_t ierr = H5Dread(dset_id, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
      H5P_DEFAULT, pts); MYH5CHECK(ierr);

  H5Dclose(dset_id);
  H5Gclose(group_id);
  H5Fclose(file_id);

  vtkUnstructuredGrid * ugrid = vtkUnstructuredGrid::New();
  ugrid->SetPoints(points);
  points->Delete();
  ugrid->Allocate(header.num_part_this_file[ptype]);
  vtkIdType onevertex;
  for(int i = 0; i < header.num_part_this_file[ptype]; ++i) {
    onevertex = i;
    ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex);
  }

  debug4 << "Done reading the \"" << string(meshname) << "\"mesh." << endl;

  return ugrid;
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

vtkDataArray *
avtGIZMOFileFormat::GetVar(const char *varname)
{
  Initialize();

  debug4 << "Reading \"" << string(varname) << "\" ..." << endl;

  assert(strlen(varname) < GIZMO_STRLEN);
  int ptype;
  char mesh_name[GIZMO_STRLEN];
  char field_name[GIZMO_STRLEN];
  sscanf(varname, "PartType%d/%s", &ptype, field_name);
  sprintf(mesh_name, "PartType%d", ptype);

  hid_t file_id = H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
    MYH5CHECK(file_id);
  hid_t group_id = H5Gopen(file_id, mesh_name, H5P_DEFAULT);
    MYH5CHECK(group_id);
  hid_t dset_id = H5Dopen(group_id, field_name, H5P_DEFAULT);
    MYH5CHECK(dset_id);

  vtkFloatArray * arr = vtkFloatArray::New();
  arr->SetNumberOfTuples(header.num_part_this_file[ptype]);
  float * ptr = reinterpret_cast<float *>(arr->GetVoidPointer(0));

  herr_t ierr = H5Dread(dset_id, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
      H5P_DEFAULT, ptr); MYH5CHECK(ierr);

  H5Dclose(dset_id);
  H5Gclose(group_id);
  H5Fclose(file_id);

  debug4 << "Done reading \"" << string(varname) << "\"." << endl;

  return arr;
}


// ****************************************************************************
//  Method: avtGIZMOFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: David Radice -- generated by xml2avt
//  Creation:   Fri Aug 1 09:27:55 PDT 2014
//
// ****************************************************************************

vtkDataArray *
avtGIZMOFileFormat::GetVectorVar(const char *varname)
{
  Initialize();

  debug4 << "Reading \"" << string(varname) << "\" ..." << endl;

  assert(strlen(varname) < GIZMO_STRLEN);
  int ptype;
  char mesh_name[GIZMO_STRLEN];
  char field_name[GIZMO_STRLEN];
  sscanf(varname, "PartType%d/%s", &ptype, field_name);
  sprintf(mesh_name, "PartType%d", ptype);

  hid_t file_id = H5Fopen(filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
    MYH5CHECK(file_id);
  hid_t group_id = H5Gopen(file_id, mesh_name, H5P_DEFAULT);
    MYH5CHECK(group_id);
  hid_t dset_id = H5Dopen(group_id, field_name, H5P_DEFAULT);
    MYH5CHECK(dset_id);

  vtkFloatArray * arr = vtkFloatArray::New();
  arr->SetNumberOfComponents(3);
  arr->SetNumberOfTuples(header.num_part_this_file[ptype]);
  float * ptr = reinterpret_cast<float *>(arr->GetVoidPointer(0));

  herr_t ierr = H5Dread(dset_id, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
      H5P_DEFAULT, ptr); MYH5CHECK(ierr);

  H5Dclose(dset_id);
  H5Gclose(group_id);
  H5Fclose(file_id);

  debug4 << "Done reading \"" << string(varname) << "\"." << endl;

  return arr;
}
